// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.5
// source: api/oauth_login.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OSOAuthLoginServiceClient is the client API for OSOAuthLoginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OSOAuthLoginServiceClient interface {
	// Ping checks connectivity between portal gateway and grpc service.
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PongResponse, error)
	// OSAuthBegin redirects to login with http.StatusTemporaryRedirect.
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OSAuthBegin(ctx context.Context, in *OSAuthBeginRequest, opts ...grpc.CallOption) (*OSAuthBeginResponse, error)
	// OSAuthRedirectUrl returns the OAuth authorization url (SeaTalk) whose param redirect uri is OSAuthCallback (OA).
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OSAuthRedirectUrl(ctx context.Context, in *OSAuthRedirectUrlRequest, opts ...grpc.CallOption) (*OSAuthRedirectUrlResponse, error)
	// OSAuthCallback is used for the callback after successful OAuth authentication.
	// This function will update cookie `_gothic_session` to mark OAuth authentication finish.
	// At the same time, this function will set cookie `_seatalk_staff_session` for OA access.
	OSAuthCallback(ctx context.Context, in *OSAuthCallbackRequest, opts ...grpc.CallOption) (*OSAuthCallbackResponse, error)
	// OSAuthHasCompany is used to check if a user has active company in OA.
	OSAuthHasCompany(ctx context.Context, in *OSAuthHasCompanyRequest, opts ...grpc.CallOption) (*OSAuthHasCompanyResponse, error)
}

type oSOAuthLoginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOSOAuthLoginServiceClient(cc grpc.ClientConnInterface) OSOAuthLoginServiceClient {
	return &oSOAuthLoginServiceClient{cc}
}

func (c *oSOAuthLoginServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PongResponse, error) {
	out := new(PongResponse)
	err := c.cc.Invoke(ctx, "/OSOAuthLoginService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oSOAuthLoginServiceClient) OSAuthBegin(ctx context.Context, in *OSAuthBeginRequest, opts ...grpc.CallOption) (*OSAuthBeginResponse, error) {
	out := new(OSAuthBeginResponse)
	err := c.cc.Invoke(ctx, "/OSOAuthLoginService/OSAuthBegin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oSOAuthLoginServiceClient) OSAuthRedirectUrl(ctx context.Context, in *OSAuthRedirectUrlRequest, opts ...grpc.CallOption) (*OSAuthRedirectUrlResponse, error) {
	out := new(OSAuthRedirectUrlResponse)
	err := c.cc.Invoke(ctx, "/OSOAuthLoginService/OSAuthRedirectUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oSOAuthLoginServiceClient) OSAuthCallback(ctx context.Context, in *OSAuthCallbackRequest, opts ...grpc.CallOption) (*OSAuthCallbackResponse, error) {
	out := new(OSAuthCallbackResponse)
	err := c.cc.Invoke(ctx, "/OSOAuthLoginService/OSAuthCallback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oSOAuthLoginServiceClient) OSAuthHasCompany(ctx context.Context, in *OSAuthHasCompanyRequest, opts ...grpc.CallOption) (*OSAuthHasCompanyResponse, error) {
	out := new(OSAuthHasCompanyResponse)
	err := c.cc.Invoke(ctx, "/OSOAuthLoginService/OSAuthHasCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OSOAuthLoginServiceServer is the server API for OSOAuthLoginService service.
// All implementations must embed UnimplementedOSOAuthLoginServiceServer
// for forward compatibility
type OSOAuthLoginServiceServer interface {
	// Ping checks connectivity between portal gateway and grpc service.
	Ping(context.Context, *PingRequest) (*PongResponse, error)
	// OSAuthBegin redirects to login with http.StatusTemporaryRedirect.
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OSAuthBegin(context.Context, *OSAuthBeginRequest) (*OSAuthBeginResponse, error)
	// OSAuthRedirectUrl returns the OAuth authorization url (SeaTalk) whose param redirect uri is OSAuthCallback (OA).
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OSAuthRedirectUrl(context.Context, *OSAuthRedirectUrlRequest) (*OSAuthRedirectUrlResponse, error)
	// OSAuthCallback is used for the callback after successful OAuth authentication.
	// This function will update cookie `_gothic_session` to mark OAuth authentication finish.
	// At the same time, this function will set cookie `_seatalk_staff_session` for OA access.
	OSAuthCallback(context.Context, *OSAuthCallbackRequest) (*OSAuthCallbackResponse, error)
	// OSAuthHasCompany is used to check if a user has active company in OA.
	OSAuthHasCompany(context.Context, *OSAuthHasCompanyRequest) (*OSAuthHasCompanyResponse, error)
	mustEmbedUnimplementedOSOAuthLoginServiceServer()
}

// UnimplementedOSOAuthLoginServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOSOAuthLoginServiceServer struct {
}

func (UnimplementedOSOAuthLoginServiceServer) Ping(context.Context, *PingRequest) (*PongResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedOSOAuthLoginServiceServer) OSAuthBegin(context.Context, *OSAuthBeginRequest) (*OSAuthBeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OSAuthBegin not implemented")
}
func (UnimplementedOSOAuthLoginServiceServer) OSAuthRedirectUrl(context.Context, *OSAuthRedirectUrlRequest) (*OSAuthRedirectUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OSAuthRedirectUrl not implemented")
}
func (UnimplementedOSOAuthLoginServiceServer) OSAuthCallback(context.Context, *OSAuthCallbackRequest) (*OSAuthCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OSAuthCallback not implemented")
}
func (UnimplementedOSOAuthLoginServiceServer) OSAuthHasCompany(context.Context, *OSAuthHasCompanyRequest) (*OSAuthHasCompanyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OSAuthHasCompany not implemented")
}
func (UnimplementedOSOAuthLoginServiceServer) mustEmbedUnimplementedOSOAuthLoginServiceServer() {}

// UnsafeOSOAuthLoginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OSOAuthLoginServiceServer will
// result in compilation errors.
type UnsafeOSOAuthLoginServiceServer interface {
	mustEmbedUnimplementedOSOAuthLoginServiceServer()
}

func RegisterOSOAuthLoginServiceServer(s grpc.ServiceRegistrar, srv OSOAuthLoginServiceServer) {
	s.RegisterService(&OSOAuthLoginService_ServiceDesc, srv)
}

func _OSOAuthLoginService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OSOAuthLoginServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OSOAuthLoginService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OSOAuthLoginServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OSOAuthLoginService_OSAuthBegin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OSAuthBeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OSOAuthLoginServiceServer).OSAuthBegin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OSOAuthLoginService/OSAuthBegin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OSOAuthLoginServiceServer).OSAuthBegin(ctx, req.(*OSAuthBeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OSOAuthLoginService_OSAuthRedirectUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OSAuthRedirectUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OSOAuthLoginServiceServer).OSAuthRedirectUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OSOAuthLoginService/OSAuthRedirectUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OSOAuthLoginServiceServer).OSAuthRedirectUrl(ctx, req.(*OSAuthRedirectUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OSOAuthLoginService_OSAuthCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OSAuthCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OSOAuthLoginServiceServer).OSAuthCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OSOAuthLoginService/OSAuthCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OSOAuthLoginServiceServer).OSAuthCallback(ctx, req.(*OSAuthCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OSOAuthLoginService_OSAuthHasCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OSAuthHasCompanyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OSOAuthLoginServiceServer).OSAuthHasCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OSOAuthLoginService/OSAuthHasCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OSOAuthLoginServiceServer).OSAuthHasCompany(ctx, req.(*OSAuthHasCompanyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OSOAuthLoginService_ServiceDesc is the grpc.ServiceDesc for OSOAuthLoginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OSOAuthLoginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "OSOAuthLoginService",
	HandlerType: (*OSOAuthLoginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _OSOAuthLoginService_Ping_Handler,
		},
		{
			MethodName: "OSAuthBegin",
			Handler:    _OSOAuthLoginService_OSAuthBegin_Handler,
		},
		{
			MethodName: "OSAuthRedirectUrl",
			Handler:    _OSOAuthLoginService_OSAuthRedirectUrl_Handler,
		},
		{
			MethodName: "OSAuthCallback",
			Handler:    _OSOAuthLoginService_OSAuthCallback_Handler,
		},
		{
			MethodName: "OSAuthHasCompany",
			Handler:    _OSOAuthLoginService_OSAuthHasCompany_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/oauth_login.proto",
}

// OAOAuthLoginServiceClient is the client API for OAOAuthLoginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OAOAuthLoginServiceClient interface {
	// OAAuthBegin redirects to login with http.StatusTemporaryRedirect.
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OAAuthBegin(ctx context.Context, in *OAAuthBeginRequest, opts ...grpc.CallOption) (*OAAuthBeginResponse, error)
	// OAAuthRedirectUrl returns the OAuth authorization url (SeaTalk) whose param redirect uri is OSAuthCallback (OA).
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OAAuthRedirectUrl(ctx context.Context, in *OAAuthRedirectUrlRequest, opts ...grpc.CallOption) (*OAAuthRedirectUrlResponse, error)
	// OAAuthCallback is used for the callback after successful OAuth authentication.
	// This function will update cookie `_gothic_session` to mark OAuth authentication finish.
	// At the same time, this function will set cookie `_seatalk_staff_session` for OA access.
	OAAuthCallback(ctx context.Context, in *OAAuthCallbackRequest, opts ...grpc.CallOption) (*OAAuthCallbackResponse, error)
}

type oAOAuthLoginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOAOAuthLoginServiceClient(cc grpc.ClientConnInterface) OAOAuthLoginServiceClient {
	return &oAOAuthLoginServiceClient{cc}
}

func (c *oAOAuthLoginServiceClient) OAAuthBegin(ctx context.Context, in *OAAuthBeginRequest, opts ...grpc.CallOption) (*OAAuthBeginResponse, error) {
	out := new(OAAuthBeginResponse)
	err := c.cc.Invoke(ctx, "/OAOAuthLoginService/OAAuthBegin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oAOAuthLoginServiceClient) OAAuthRedirectUrl(ctx context.Context, in *OAAuthRedirectUrlRequest, opts ...grpc.CallOption) (*OAAuthRedirectUrlResponse, error) {
	out := new(OAAuthRedirectUrlResponse)
	err := c.cc.Invoke(ctx, "/OAOAuthLoginService/OAAuthRedirectUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oAOAuthLoginServiceClient) OAAuthCallback(ctx context.Context, in *OAAuthCallbackRequest, opts ...grpc.CallOption) (*OAAuthCallbackResponse, error) {
	out := new(OAAuthCallbackResponse)
	err := c.cc.Invoke(ctx, "/OAOAuthLoginService/OAAuthCallback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OAOAuthLoginServiceServer is the server API for OAOAuthLoginService service.
// All implementations must embed UnimplementedOAOAuthLoginServiceServer
// for forward compatibility
type OAOAuthLoginServiceServer interface {
	// OAAuthBegin redirects to login with http.StatusTemporaryRedirect.
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OAAuthBegin(context.Context, *OAAuthBeginRequest) (*OAAuthBeginResponse, error)
	// OAAuthRedirectUrl returns the OAuth authorization url (SeaTalk) whose param redirect uri is OSAuthCallback (OA).
	// This function will set cookie `_gothic_session` to mark Oauth authentication start.
	OAAuthRedirectUrl(context.Context, *OAAuthRedirectUrlRequest) (*OAAuthRedirectUrlResponse, error)
	// OAAuthCallback is used for the callback after successful OAuth authentication.
	// This function will update cookie `_gothic_session` to mark OAuth authentication finish.
	// At the same time, this function will set cookie `_seatalk_staff_session` for OA access.
	OAAuthCallback(context.Context, *OAAuthCallbackRequest) (*OAAuthCallbackResponse, error)
	mustEmbedUnimplementedOAOAuthLoginServiceServer()
}

// UnimplementedOAOAuthLoginServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOAOAuthLoginServiceServer struct {
}

func (UnimplementedOAOAuthLoginServiceServer) OAAuthBegin(context.Context, *OAAuthBeginRequest) (*OAAuthBeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OAAuthBegin not implemented")
}
func (UnimplementedOAOAuthLoginServiceServer) OAAuthRedirectUrl(context.Context, *OAAuthRedirectUrlRequest) (*OAAuthRedirectUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OAAuthRedirectUrl not implemented")
}
func (UnimplementedOAOAuthLoginServiceServer) OAAuthCallback(context.Context, *OAAuthCallbackRequest) (*OAAuthCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OAAuthCallback not implemented")
}
func (UnimplementedOAOAuthLoginServiceServer) mustEmbedUnimplementedOAOAuthLoginServiceServer() {}

// UnsafeOAOAuthLoginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OAOAuthLoginServiceServer will
// result in compilation errors.
type UnsafeOAOAuthLoginServiceServer interface {
	mustEmbedUnimplementedOAOAuthLoginServiceServer()
}

func RegisterOAOAuthLoginServiceServer(s grpc.ServiceRegistrar, srv OAOAuthLoginServiceServer) {
	s.RegisterService(&OAOAuthLoginService_ServiceDesc, srv)
}

func _OAOAuthLoginService_OAAuthBegin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OAAuthBeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OAOAuthLoginServiceServer).OAAuthBegin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OAOAuthLoginService/OAAuthBegin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OAOAuthLoginServiceServer).OAAuthBegin(ctx, req.(*OAAuthBeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OAOAuthLoginService_OAAuthRedirectUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OAAuthRedirectUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OAOAuthLoginServiceServer).OAAuthRedirectUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OAOAuthLoginService/OAAuthRedirectUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OAOAuthLoginServiceServer).OAAuthRedirectUrl(ctx, req.(*OAAuthRedirectUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OAOAuthLoginService_OAAuthCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OAAuthCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OAOAuthLoginServiceServer).OAAuthCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OAOAuthLoginService/OAAuthCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OAOAuthLoginServiceServer).OAAuthCallback(ctx, req.(*OAAuthCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OAOAuthLoginService_ServiceDesc is the grpc.ServiceDesc for OAOAuthLoginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OAOAuthLoginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "OAOAuthLoginService",
	HandlerType: (*OAOAuthLoginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OAAuthBegin",
			Handler:    _OAOAuthLoginService_OAAuthBegin_Handler,
		},
		{
			MethodName: "OAAuthRedirectUrl",
			Handler:    _OAOAuthLoginService_OAAuthRedirectUrl_Handler,
		},
		{
			MethodName: "OAAuthCallback",
			Handler:    _OAOAuthLoginService_OAAuthCallback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/oauth_login.proto",
}
